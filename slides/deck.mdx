import { Image, Notes, Appear, Split } from 'mdx-deck';
import withHocSc from '../static/with-hoc-sc.png';
import noHocSc from '../static/no-hocs-sc.png';
import { DeclaringComponents, CodeBlock } from './components';

export const theme = {
  colors: {
    text: '#fff',
    background: '#130a3e',
    primary: '#08f',
    secondary: '#f0f',
    darkgray: '#333'
  },
  styles: {
    li: {
      marginBottom: '2rem'
    }
  }
};

# Writing Modern <br /> & Opinionated React

<Notes>Modern as of now, maybe not in a year</Notes>

---

# React is unopinionated, so we need to be

<Appear>
  <div>
    <CodeBlock>
      {`return (
  <div>
    <p>Some kind of content</p>
  </div>
);
`}
    </CodeBlock>
  </div>
</Appear>

<Notes>
  React has a few rules, but those aside as long as your component returns JSX it is happy days
</Notes>

---

# Guiding Principles

1. Spend your decision capital wisely
2. Be cognizant of your team's decision capital
3. Apply conventions, known or inferred
4. Generally choose safe over exiting

---

# But First

---

# Worlds Fastest Crash Course

### A speedy run through of some essentials

<Notes>Declaring components and component lifecycle</Notes>

---

## Declaring Components

### Class Components

<DeclaringComponents />

<Notes>Class component, it's just inheritance and implementation</Notes>

---

## Declaring Components

### Function Components

<CodeBlock>
  {`const AirlineFood: React.FC<Props> = props => {
  return (
    <div>
      {props.text}
      <p>What's the deal with airline food?</p>
    </div>
  );
};
`}
</CodeBlock>

<Notes>Nothing to implement, just return valid jsx</Notes>

---

## Declaring Components

### Function Components with State

<CodeBlock>
  {`
const AirlineFood: React.FC<Props> = props => {
  const [open, setIsOpen] = useState(false);
  return (
    <div>
      {props.text}
      <p>What's the deal with airline food?</p>
    </div>
  );
};
`}
</CodeBlock>

<Notes>useState uses array destructuing, like a tuple in C#</Notes>

---

# Component Lifecycle

<Notes>The order in which things happen</Notes>

---

## Mounting

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // mounting
  constructor(props: Props) {
    super(props);
  }
  static getDerivedStateFromProps = (props: Props, state: State) => {};
  componentDidMount = () => {};
  render() {
    return (
      <div>
        {this.props.text}
      </div>
    );
  }
}
`}
</CodeBlock>

<Notes>
  gDSFP return object to update state, doesn't have acccess to instance. Everything here is optional
</Notes>

---

## Updating

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // updating
  componentDidUpdate = (prevProps: Props, prevState: State) => {};
  shouldComponentUpdate = (nextProps: Props, nextState: State) => {
    return false;
  };
  render() {
    return (
      <div>
        {this.props.text}
      </div>
    );
  }
}
`}

</CodeBlock>

---

## Unmounting

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // unmounting
  componentWillUnmount = () => {};
}
`}

</CodeBlock>

---

## Use what you need

- You (probably) never need a constructor
- Most work handled in `componentDidMount` and `componentDidUpdate`

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // never do this
  constructor(props: Props) {
    super(props);
    this.state = { open: false };
    this.getFood = this.getFood.bind(this);
  }
  getFood() {
    //
  }
}
`}

</CodeBlock>

---

# React is Functional-ish

- No mutation\*
- Explicit side-effects
- A whole lot of new copies of data

\*Excludes component state in class components.

---

# React is Functional-ish

<CodeBlock>
  {`const AirlineFood: React.FC<Props> = props => {
  const [open, setIsOpen] = useState(false);
  return (
    <div>
      {props.data.map((d, idx) => (
        <p key={idx}>{d}</p>
      ))}
    </div>
  );
};
`}

</CodeBlock>

---

## Functional-ish React

- Important with React e.g.: new state, explicit side effects
- Important with Redux e.g.: only returning new state, debugging
- Potentially representative in labour-market skill shift
- A lot of new developers will indirectly and unknowingly learn functional programming concepts this way

---

## Functional-ish React

A popular feature of many FP languages is pattern matching. This is the current
proposal in stage 1

<CodeBlock>
  {`const res = await fetch(jsonService)
case (res) {
  when {status: 200, headers: {'Content-Length': s}} ->
    console.log(\`size is \${s}\`),
  when {status: 404} ->
    console.log('JSON not found'),
  when {status} if (status >= 400) -> {
    throw new RequestError(res)
  },
}`}
</CodeBlock>

---

## Functional-ish React

And it's _quite_ similar to pattern matching in languages like Elixir

<CodeBlock language="elixir">
  {`defmodule Server.FileHandler do
  def handle_file({:ok, content}, conv) do
    %{conv | status: 200, resp_body: content}
  end
#
  def handle_file({:error, :enoent}, conv) do
    %{conv | status: 404, resp_body: "File not found!"}
  end
#
  def handle_file({:error, reason}, conv) do
    %{conv | status: 500, resp_body: "File error: #{reason}"}
  end
end`}
</CodeBlock>

---

# Opinion Time

---

# Always use create-react-app

### Unless you have a damn good reason not to

---

# create-react-app

- Easy to use: `npx create-react-app modern-react --typescript`
- Sensible defaults:
  - Linting
  - Minification
  - Webpack and babel config, modern JS
  - Test runner
  - CSS & SCSS support, autoprefixing
  - Static asset imports
- Battle tested and proven
- You can always `eject`

---

# Avoid Higher Order Components

### Where practical.

---

# Avoid HOCs

### They are _not fun_ to type

<CodeBlock>
  {`// props for our HOC
export interface WithThemeProps {
  primaryColor: string;
}
// Props for our actual component
export interface Props extends WithThemeProps {
  children: React.ReactNode;
}
// the HOC itself
export function withTheme<T extends WithThemeProps = WithThemeProps>(
  WrappedComponent: React.ComponentType<T>
) {
  // render wrapped component
  return class ComponentWithTheme extends React.Component<T, WithThemeProps> {
    // a method to get the theme
    getThemeProps = () => {};
    render() {
      // Fetch props to inject
      const themeProps = this.getThemeProps();
      // apply the necessary props
      return <WrappedComponent {...themeProps} {...(this.props as T)} />;
    }
  };
}`}
</CodeBlock>
<CodeBlock>
{`export class MyButton extends React.Component<Props> {
  // The theme values are also available as props here.
  internalMethod = () => {
    const color = this.props.primaryColor;
  };
  render() {
    return <button>submit</button>;
  }
}
`}
</CodeBlock>

---

<Image src={withHocSc} />

---

<Image src={noHocSc} />

---

# Function Components<br/>over Class Components

### Also where practical which is 99% of the time

---

# Functions over Classes

- Easier for humans and computers to understand
- No use of this (a semi big deal; reasons to come)
- Colocated lifecycle functionality
- _Way_ easier to share logic
- The most common component in contemporary React

---

# Functions over Classes

### Simpler Declarations

Much more to come on this.

<div style={{display:`flex`}}>
<CodeBlock>
  {`const FnComp = () => {
  return (
    <div>
      <p>content</p>
    </div>
  );
};
`}
</CodeBlock>

<CodeBlock>
  {`class ClassComp extends React.Component {
  render() {
    return (
      <div>
        <p>content</p>
      </div>
    );
  }
}`}
</CodeBlock>

</div>

---

# Pick a style and stick to it

---

# Pick a style and stick to it

<div style={{display:`flex`}}>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Do This</h2>

<CodeBlock>
  {`const MyComponent: React.FC = () => {
  const handleClick = (e: MouseEvent) => {
    // do something
  };
  return (
    <div>
      <p>things</p>
    </div>
  );
};
`}
</CodeBlock>
</div>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Or This</h2>
<CodeBlock>
  {`const MyComponent: React.FC = () => {
  function handleClick(e: MouseEvent) {
    // do something
  }
  return (
    <div>
      <p>things</p>
    </div>
  );
};`}
</CodeBlock>

</div>
</div>

---

# Pick a style and stick to it

## Just don't do this

<CodeBlock>
  {`class BadForm extends React.Component {
  componentDidMount() {
    //
  }
  handleClick = () => {
    //
  };
}`}
</CodeBlock>

---

# ABD

### Always be Destructuring

---

# ABD

<div style={{display:`flex`}}>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Do This</h2>

<CodeBlock>
  {`const ABD: React.FC<Props> = ({
    msg,
    data,
    nest
  }) => {
  const { anotherOne } = nest;
  return (
    <div>
      <p>
        {msg} - {anotherOne}
      </p>
      {data.map((d, idx) => (
        <span key={idx}>{d}</span>
      ))}
    </div>
  );
};
`}
</CodeBlock>

</div>

<div style={{display:`flex`, flexDirection: 'column'}}>

<h2 style={{textAlign:'center'}}>Not This</h2>

<CodeBlock >
  {`class NoDesctruct extends React.Component<Props> {
  render() {
    // const { msg, data, nest } = this.props;
    return (
      <div>
        <p>
          {this.props.msg} - {this.props.nest.anotherOne}
        </p>
        {this.props.data.map((d, idx) => (
          <span key={idx}>{d}</span>
        ))}
      </div>
    );
  }
}
`}

</CodeBlock>

</div>
</div>

---

# ABD

Rename as the need arises or it makes sense.

<CodeBlock>{` const { poorlyNamedItem: data } = props.meta; `}</CodeBlock>

---

# Create conventional component APIs

### No exceptions.

---

# Component APIs

<div style={{ overflow: 'auto' }}>
  <CodeBlock customStyle={{ overflow: 'unset' }}>
    {`const App = () => {
  const [name, setName] = useState('');\n
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
  };\n
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
  };\n
  return (
    <div>
      <SimpleForm handleChange={handleChange} handleSubmit={handleSubmit} />
    </div>
  );
};`}
</CodeBlock>

<CodeBlock customStyle={{ overflow: 'unset' }}>
  {`const SimpleForm: React.FC<GoodProps> = ({ handleSubmit, handleChange }) => {
  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="name">Name</label>
      <input onChange={handleChange} type="text" name="name" />
    </form>
  );
};`}
</CodeBlock>

</div>

---

# Component APIs

<div style={{ overflow: 'auto' }}>

<CodeBlock customStyle={{ overflow: 'unset' }}>
  {`
interface GoodProps {
  handleChange: (e: ChangeEvent<HTMLInputElement>) => void;
  handleSubmit: (e: FormEvent<HTMLFormElement>) => void;
  // onChange: (e: ChangeEvent<HTMLInputElement>) => void;
}`}
</CodeBlock>

<CodeBlock customStyle={{ overflow: 'unset' }}>
    {`interface BadProps {
  keyboardCallback: (e: React.ChangeEvent<HTMLInputElement>) => void;
  formSubmission: (e: React.FormEvent) => void;
}`}
</CodeBlock>
</div>

---

# Don't make me think

<CodeBlock>
{`<IncorrectBarcodeModal
  isActive={this.state.showIncorrectBarcodeModal}
  closeModalHandler={() =>
    this.setState({ showIncorrectBarcodeModal: false })
  }
/>

<ModalWrapper
  isActive={showModal}
  hasCloseButton={true}
  onCloseHandler={() => {
    setModalVisibility(false);
  }}
  classNames="z-max"
    >

<ConfirmAndProceedBox
    marketing_opt_in={this.props.marketing_opt_in}
    termsAndConditionsChecked={
  this.props.termsAndConditionsChecked
    }
    marketingOffersCallback={checked =>
  this.props.marketingOffersChanged(checked)
    }
    termsAndConditionsCallback={checked =>
  this.props.termsAndConditionsChanged(checked)
    }
  />`}
</CodeBlock>

---

# Project Structure

### Use what makes sense, but also do what I tell you

---

# Project Structure

Show good and bad

---

# TODO

1. Semantic HTML
2. Stop using divs for everything/use fragment
3. When to decompose components (todo list example)
4. Why not using classes is a great thing (PM example)
5. Hooks, all about hooks.
