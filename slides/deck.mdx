import { Image, Notes, Appear, Split, Horizontal } from 'mdx-deck';
import withHocSc from '../static/with-hoc-sc.png';
import noHocSc from '../static/no-hocs-sc.png';
import projectStructure from '../static/project-structure.png';
import care from '../static/care.png';
import { DeclaringComponents, CodeBlock, Care } from './components';

export const theme = {
  colors: {
    text: '#fff',
    background: '#130a3e',
    primary: '#08f',
    secondary: '#f0f',
    darkgray: '#333'
  },
  styles: {
    li: {
      marginBottom: '2rem'
    }
  }
};

# Writing Modern <br /> & Opinionated React

<Notes>Modern as of now, maybe not in a year</Notes>

---

# React is unopinionated, so we need to be

<Appear>
  <div>
    <CodeBlock>
      {`return (
  <div>
    <p>Some kind of content</p>
  </div>
);
`}
    </CodeBlock>
  </div>
</Appear>

<Notes>
  React has a few rules, but those aside as long as your component returns JSX it is happy days
</Notes>

---

# Guiding Principles

1. Spend your decision capital wisely
2. Be cognizant of your team's decision capital
3. Apply conventions, known or inferred
4. Generally choose safe over exiting
5. Stay with, not necessarily ahead of, the curve

---

# But First

---

# Worlds Fastest Crash Course

### A speedy run through of some essentials

<Notes>Declaring components and component lifecycle</Notes>

---

## Declaring Components

### Class Components

<DeclaringComponents />

<Notes>Class component, it's just inheritance and implementation</Notes>

---

## Declaring Components

### Function Components

<CodeBlock>
  {`const AirlineFood: React.FC<Props> = props => {
  return (
    <div>
      {props.text}
      <p>What's the deal with airline food?</p>
    </div>
  );
};
`}
</CodeBlock>

<Notes>Nothing to implement, just return valid jsx</Notes>

---

## Declaring Components

### Function Components with State

<CodeBlock>
  {`
const AirlineFood: React.FC<Props> = props => {
  const [open, setIsOpen] = useState(false);
  return (
    <div>
      {props.text}
      <p>What's the deal with airline food?</p>
    </div>
  );
};
`}
</CodeBlock>

<Notes>useState uses array destructuing, like a tuple in C#</Notes>

---

# Component Lifecycle

<Notes>The order in which things happen</Notes>

---

## Mounting

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // mounting
  constructor(props: Props) {
    super(props);
  }
  static getDerivedStateFromProps = (props: Props, state: State) => {};
  componentDidMount = () => {};
  render() {
    return (
      <div>
        {this.props.text}
      </div>
    );
  }
}
`}
</CodeBlock>

<Notes>
  gDSFP return object to update state, doesn't have acccess to instance. Everything here is optional
</Notes>

---

## Updating

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // updating
  componentDidUpdate = (prevProps: Props, prevState: State) => {};
  shouldComponentUpdate = (nextProps: Props, nextState: State) => {
    return false;
  };
  render() {
    return (
      <div>
        {this.props.text}
      </div>
    );
  }
}
`}

</CodeBlock>

---

## Unmounting

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // unmounting
  componentWillUnmount = () => {};
}
`}

</CodeBlock>

---

## Use what you need

- You (probably) never need a constructor
- Most work handled in `componentDidMount` and `componentDidUpdate`

<CodeBlock>
  {`class AirlineFood extends Component<Props, State> {
  // never do this
  constructor(props: Props) {
    super(props);
    this.state = { open: false };
    this.getFood = this.getFood.bind(this);
  }
  // state can be declared like so
  state = { open: false };
  // if you declared this as \`getFood = () => {}\`
  // it's automatically bound
  getFood() {
  }
}
`}

</CodeBlock>

---

# React is Functional-ish

- No mutation\*
- Explicit side-effects
- A whole lot of new copies of data

\*Excludes component state in class components.

---

# React is Functional-ish

<CodeBlock>
  {`const AirlineFood: React.FC<Props> = props => {
  const [open, setIsOpen] = useState(false);
  return (
    <div>
      {props.data.map((d, idx) => (
        <p key={idx}>{d}</p>
      ))}
    </div>
  );
};
`}

</CodeBlock>

---

# Functional-ish React

- Important with React e.g.: new state, explicit side effects
- Important with Redux e.g.: only returning new state, debugging
- Potentially representative in labour-market skill shift
- A lot of new developers will unknowingly learn functional programming concepts this way

---

## Functional-ish React

A popular feature of many FP languages is pattern matching. This is the current
proposal in stage 1

<CodeBlock>
  {`const res = await fetch(jsonService)
case (res) {
  when {status: 200, headers: {'Content-Length': s}} ->
    console.log(\`size is \${s}\`),
  when {status: 404} ->
    console.log('JSON not found'),
  when {status} if (status >= 400) -> {
    throw new RequestError(res)
  },
}`}
</CodeBlock>

<Notes>
  JS has been through a few years of rapid change and improvement, and in the JS world new features,
  syntaxes, etc, become commonly used faster than in other languages/ecosystems
</Notes>

---

## Functional-ish React

And it's _quite_ similar to pattern matching in languages like Elixir

<CodeBlock language="elixir">
  {`defmodule Server.FileHandler do
  def handle_file({:ok, content}, conv) do
    %{conv | status: 200, resp_body: content}
  end
#
  def handle_file({:error, :enoent}, conv) do
    %{conv | status: 404, resp_body: "File not found!"}
  end
#
  def handle_file({:error, reason}, conv) do
    %{conv | status: 500, resp_body: "File error: #{reason}"}
  end
end`}
</CodeBlock>

<Notes>
  Similar to method overloading but you don't check object internals first and if/else it you just
  call the method with the object and let the runtime figure it out
</Notes>

---

# Opinionated React

---

# Always use create-react-app

### Unless you have a damn good reason not to

---

# create-react-app

- Easy to use: `npx create-react-app modern-react --typescript`
- Sensible defaults:
  - Linting
  - Minification
  - Webpack and babel config, modern JS
  - Test runner
  - CSS & SCSS support, autoprefixing
  - Static asset imports
- Battle tested and proven
- You can always `eject`

---

# Avoid Higher Order Components

### Where practical.

---

# Avoid HOCs

### They are _not fun_ to type

<div style={{overflow:'auto'}}>

<CodeBlock customStyle={{overflow:'unset'}}>
  {`// props for our HOC
export interface WithThemeProps {
  primaryColor: string;
}
// Props for our actual component
export interface Props extends WithThemeProps {
  children: React.ReactNode;
}
// the HOC itself
export function withTheme<T extends WithThemeProps = WithThemeProps>(
  WrappedComponent: React.ComponentType<T>
) {
  // render wrapped component
  return class ComponentWithTheme extends React.Component<T, WithThemeProps> {
    // a method to get the theme
    getThemeProps = () => {};
    render() {
      // Fetch props to inject
      const themeProps = this.getThemeProps();
      // apply the necessary props
      return <WrappedComponent {...themeProps} {...(this.props as T)} />;
    }
  };
}`}
</CodeBlock>
<CodeBlock>
{`export class MyButton extends React.Component<Props> {
  // The theme values are also available as props here.
  internalMethod = () => {
    const color = this.props.primaryColor;
  };
  render() {
    return <button>submit</button>;
  }
}
`}
</CodeBlock>

</div>

---

<Image src={withHocSc} />

---

<Image src={noHocSc} />

---

# Function Components<br/>over Class Components

### Also where practical which is 99% of the time

---

# Functions over Classes

- Easier for humans and computers to understand
- No use of `this` (a semi big deal; reasons to come)
- Colocated lifecycle functionality
- _Way_ easier to share logic
- The most common component in contemporary React

---

# Functions over Classes

### Simpler Declarations

<div style={{display:`flex`}}>
<CodeBlock>
  {`const FnComp = () => {
  return (
    <div>
      <p>content</p>
    </div>
  );
};
`}
</CodeBlock>

<CodeBlock>
  {`class ClassComp extends React.Component {
  render() {
    return (
      <div>
        <p>content</p>
      </div>
    );
  }
}`}
</CodeBlock>

</div>

<Notes>A new render means a new component</Notes>

---

# Pick a style and stick to it

---

# Pick a style and stick to it

<div style={{display:`flex`}}>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Do This</h2>

<CodeBlock>
  {`const MyComponent: React.FC = () => {
  const handleClick = (e: MouseEvent) => {
    // do something
  };
  return (
    <div>
      <p>things</p>
    </div>
  );
};
`}
</CodeBlock>
</div>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Or This</h2>
<CodeBlock>
  {`const MyComponent: React.FC = () => {
  function handleClick(e: MouseEvent) {
    // do something
  }
  return (
    <div>
      <p>things</p>
    </div>
  );
};`}
</CodeBlock>

</div>
</div>

---

# Pick a style and stick to it

## Just don't do this

<CodeBlock>
  {`class BadForm extends React.Component {
  componentDidMount() {
    //
  }
  handleClick = () => {
    //
  };
}`}
</CodeBlock>

---

# ABD

### Always be Destructuring

---

# ABD

<div style={{display:`flex`}}>
<div style={{display:`flex`, flexDirection: 'column'}}>
<h2 style={{textAlign:'center'}}>Do This</h2>

<CodeBlock>
  {`const ABD: React.FC<Props> = ({
    msg,
    data,
    nest
  }) => {
  const { anotherOne } = nest;
  return (
    <div>
      <p>
        {msg} - {anotherOne}
      </p>
      {data.map((d, idx) => (
        <span key={idx}>{d}</span>
      ))}
    </div>
  );
};
`}
</CodeBlock>

</div>

<div style={{display:`flex`, flexDirection: 'column'}}>

<h2 style={{textAlign:'center'}}>Not This</h2>

<CodeBlock >
  {`class NoDesctruct extends React.Component<Props> {
  render() {
    // const { msg, data, nest } = this.props;
    return (
      <div>
        <p>
          {this.props.msg} - {this.props.nest.anotherOne}
        </p>
        {this.props.data.map((d, idx) => (
          <span key={idx}>{d}</span>
        ))}
      </div>
    );
  }
}
`}

</CodeBlock>

</div>
</div>

---

# ABD

Rename as the need arises or it makes sense.

<CodeBlock>{` const { poorlyNamedItem: data } = props.meta; `}</CodeBlock>

---

# Create conventional component APIs

### No exceptions.

---

# Component APIs

<div style={{ overflow: 'auto' }}>
  <CodeBlock customStyle={{ overflow: 'unset' }}>
    {`const App = () => {
  const [name, setName] = useState('');\n
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
  };\n
  const handleSubmit = (e: FormEvent<HTMLFormElement>) => {
    e.preventDefault();
  };\n
  return (
    <div>
      <SimpleForm handleChange={handleChange} handleSubmit={handleSubmit} />
    </div>
  );
};`}
</CodeBlock>

<CodeBlock customStyle={{ overflow: 'unset' }}>
  {`const SimpleForm: React.FC<GoodProps> = ({ handleSubmit, handleChange }) => {
  return (
    <form onSubmit={handleSubmit}>
      <label htmlFor="name">Name</label>
      <input onChange={handleChange} type="text" name="name" />
    </form>
  );
};`}
</CodeBlock>

</div>

<Notes>Name props and whatever those are identically and keep them consistent.</Notes>

---

# Component APIs

<div style={{ overflow: 'auto' }}>

<CodeBlock customStyle={{ overflow: 'unset' }}>
  {`
interface GoodProps {
  handleChange: (e: ChangeEvent<HTMLInputElement>) => void;
  handleSubmit: (e: FormEvent<HTMLFormElement>) => void;
  // onChange: (e: ChangeEvent<HTMLInputElement>) => void;
}`}
</CodeBlock>

<CodeBlock customStyle={{ overflow: 'unset' }}>
    {`interface BadProps {
  keyboardCallback: (e: React.ChangeEvent<HTMLInputElement>) => void;
  formSubmission: (e: React.FormEvent) => void;
}`}
</CodeBlock>
</div>

---

# Don't make me think

<CodeBlock>
{`<IncorrectBarcodeModal
  closeModalHandler={() =>
    this.setState({ showIncorrectBarcodeModal: false })
  }
/>

<ModalWrapper
  onCloseHandler={() => {
    setModalVisibility(false);
  }}
/>

<ConfirmAndProceedBox
  marketingOffersCallback={checked =>
    this.props.marketingOffersChanged(checked)
  }
  termsAndConditionsCallback={checked =>
    this.props.termsAndConditionsChanged(checked)
  }
 />`}
</CodeBlock>

---

# Project Structure

### There are no rules but also there are

---

# Project Structure

<Image src={projectStructure} size="contain" />

<Notes>Components can be grouped by domain, page, category, whatever</Notes>

---

# Art Vandelay

### Care about importing and exporting

---

# Art Vandelay

<CodeBlock>
  {`import React from 'react';
import Button from '../ArtVandelay/Button';
import Card from '../ArtVandelay/Card';
import Table from '../ArtVandelay/Table';\n
export const App: React.FC = () => {
  return (
    <div>
      <Button disabled={false} type="button" />
      <Card title="My Card" />
      <Table />
    </div>
  );
};`}
</CodeBlock>

---

<CodeBlock>
  {`// index.ts
export * from './Button';
export * from './Card';
export * from './Table';\n
// App.tsx
import React from 'react';
import { Button, Card, Table } from '../ArtVandelay';\n
export const App: React.FC = () => {
  return (
    <>
      <Button disabled={false} type="button" />
      <Card title="My Card" />
      <Table />
    </>
  );
};
`}
</CodeBlock>

---

# Write Semantic HTML

### It exists to convey meaning so you should allow it

---

# Write Semantic HTML

<CodeBlock>
  {`export const Bad = () => {
  return (
    <div className="main">
      <div className="header">Cool Page</div>
      <div className="main">
        <div className="title">Cool Content</div>
        <div className="content">
          <p>How's about that sports game</p>
        </div>
      </div>
    </div>
  );
};`}
</CodeBlock>

---

# Write Semantic HTML

<CodeBlock>
  {`export const Good = () => {
  return (
    <main>
      <header>Cool Page</header>
      <article>
        <h1>Cool Content</h1>
        <section>
          <p>How's about that sports game</p>
        </section>
      </article>
    </main>
  );
};`}
</CodeBlock>

---

# Use Fragments, not extraneous divs

---

# Use Fragments, not extraneous divs

<CodeBlock>
  {`const AngryReact = () => {
  return (
      <p>Some kind of content</p>
      <p>Another kind of content</p>
  );
}`}
</CodeBlock>

<Notes>JSX needs strictly one parent</Notes>

---

# Use Fragments, not extraneous divs

<CodeBlock>
  {`const NoFragments = () => {
  return (
    <div>
      <p>Some kind of content</p>
      <p>Another kind of content</p>
    </div>
  );
};`}
</CodeBlock>

---

# How good are Fragments?

<Horizontal>

<CodeBlock customStyle={{ paddingLeft: 0, paddingRight: 0, fontSize: `50px` }}>
  {`const Fragments = () => {
  return (
    <React.Fragment>
      <p>Some kind of content</p>
      <p>Another kind of content</p>
    </React.Fragment>
  );
};`}
</CodeBlock>

<CodeBlock customStyle={{ paddingLeft: 0, paddingRight: 0, fontSize: `50px` }}>
  {`const Fragments = () => {
  return (
    <Fragment>
      <p>Some kind of content</p>
      <p>Another kind of content</p>
    </Fragment>
  );
};`}
</CodeBlock>

<CodeBlock customStyle={{ paddingLeft: 0, paddingRight: 0, fontSize: `50px` }}>
  {`const Fragments = () => {
  return (
    <>
      <p>Some kind of content</p>
      <p>Another kind of content</p>
    </>
  );
};`}
</CodeBlock>

</Horizontal>

---

# Decomposing JSX into Components

### Make components when it makes sense

---

# Decomposing JSX into Components

<CodeBlock>
  {`const App = () => {
  const items = getItems();
  const comments = getComments();
  return (
    <main>
      <header>My Cool Page</header>
      <section>
        {items.map((item, index) => (
          <article key={index}>
            <h2>{item.title}</h2>
            <p>{item.body}</p>
          </article>
        ))}
      </section>
      <section>
        {comments.map((cmt, index) => (
          <article key={index}>
            <p>{cmt.comment}</p>
            <small>By {cmt.author}</small>
          </article>
        ))}
      </section>
    </main>
  );
};`}
</CodeBlock>

---

# Decomposing into Components

<Horizontal>

<CodeBlock customStyle={{ fontSize: `50px` }}>
  {`const Items: React.FC<ItemProps> = ({
  items
}) => {
  return (
    <section>
      {items.map((item, index) => (
        <article key={index}>
          <h2>{item.title}</h2>
          <p>{item.body}</p>
        </article>
      ))}
    </section>
  );
};`}
</CodeBlock>

<CodeBlock customStyle={{ fontSize: `50px` }}>
  {`const Comments: React.FC<CommentProps> = ({
  comments
}) => {
  return (
    <section>
      {comments.map((cmt, index) => (
        <article key={index}>
          <p>{cmt.comment}</p>
          <small>By {cmt.author}</small>
        </article>
      ))}
    </section>
  );
};`}
</CodeBlock>

</Horizontal>

---

# Decomposing into Components

<CodeBlock>
  {`const App = () => {
  const items: Item[] = getItems();
  const comments: Comment[] = getComments();
  return (
    <main>
      <header>My Cool Page</header>
      <Items items={items} />
      <Comments comments={comments} />
    </main>
  );
};`}
</CodeBlock>

<Notes>Est 35 minutes to this point</Notes>

---

# Functions Over Classes

<Appear>
<div>
<Care />
</div>
<h2>Class Abuse Resistance Education</h2>

</Appear>

---

# Class Abuse Resistance Education

<CodeBlock>
  {`// wait for 5 milliseconds for keyboard to populate value in input
if (this.props.element.type === 'text') {
  setTimeout(() => {
    this.switchTitle(this.props.element.value);
  }, 5);
}`}
</CodeBlock>

---

# Big one

<CodeBlock>
  {`import React from 'react';
import Keyboard from 'react-simple-keyboard';
import { connect } from 'react-redux';
import { remote } from 'electron';
import { Dispatch } from 'redux';
import scrollIntoView from 'scroll-into-view-if-needed';
import { AppState } from '@/store';
import { showKeyboard } from '@/store/Keyboard/actions';
import 'react-simple-keyboard/build/css/index.css';
import './Keyboard.scss';\n
const keyboardLayout = {
  default: [
    '1 2 3 4 5 6 7 8 9 0 {bksp}',
    '{tab} q w e r t y u i o p _',
    '{lock} a s d f g h j k l /',
    '{shift} z x c v b n m , . @',
    '{kbdwn} {space}'
  ],
  shift: [
    '1 2 3 4 5 6 7 8 9 0 {bksp}',
    '{tab} ~ ! # \$ % ^ & \* ( ) _',
    '{lock} \` " [ ] { } = + - /',
    '{abc} | \\ < > ? ; : , . @',
    '{kbdwn} {space}'
  ],
  lock: [
    '1 2 3 4 5 6 7 8 9 0 {bksp}',
    '{tab} Q W E R T Y U I O P _',
    '{lock} A S D F G H J K L /',
    '{shift} Z X C V B N M , . @',
    '{kbdwn} {space}'
  ],
  number: [' 1 2 3', '{tab} 4 5 6', '{bksp} 7 8 9', '{kbdwn} 0']
};\n
const display = {
  '{bksp}': 'delete',
  '{shift}': '#+=',
  '{abc}': 'abc',
  '{kbdwn}': ' ',
  '{tab}': 'tab',
  '{rtab}': '&uarr;'
};\n
// Map keyboard events to https://electronjs.org/docs/api/accelerator
const specialKeyMap = {
  '{space}': ' ',
  '{bksp}': 'Backspace',
  '{tab}': 'Tab',
  '{rtab}': 'shift+Tab'
} as any;\n
const buttonTheme = [
  {
    class: 'hide-keyboard-button',
    buttons: '{kbdwn}'
  }
];\n
interface AppKeyboardProps {
  isActive: boolean;
  form: string;
  field: string;
  element: HTMLInputElement;
  showKeyboard: (show: boolean) => void;
}\n
interface AppKeyboardState {
  layout: string;
}
class AppKeyboard extends React.Component<AppKeyboardProps, AppKeyboardState> {
  state = { layout: 'lock' };
  constructor(props: AppKeyboardProps) {
    super(props);
  }
  componentDidUpdate = (prevProps: AppKeyboardProps) => {
    const { field, element, isActive } = this.props;
    if (prevProps.field !== field && element) {
      const { type, value } = element;
      let layout = 'default';
      // decide layout for the input that has been focused.
      switch (type) {
        case 'tel':
        case 'number':
          layout = 'number';
          this.setState({ layout });
          break;
        case 'email':
          this.setState({ layout });
          break;
        case 'text':
          this.switchTitle(value);
        default:
        break;
      }
    }
    if (isActive) {
      scrollIntoView(element, {
        scrollMode: 'if-needed',
        block: 'start',
        inline: 'start',
        behavior: 'instant'
      });
    }
  };\n
  onKeyPress = (button: string) => {
    const { layout } = this.state;
    if (['{shift}', '{abc}'].includes(button)) {
      this.setState({
        layout: layout === 'shift' ? 'default' : 'shift'
      });
    } else if (button === '{lock}') {
      this.setState({
        layout: layout === 'lock' ? 'default' : 'lock'
      });
    } else if (button === '{kbdwn}') {
      this.props.element.blur();
    } else {
      setImmediate(() => {
        let window = remote.webContents.getFocusedWebContents();
        if (window) {
          if (specialKeyMap[button]) {
            let modifiers = specialKeyMap[button].split('+');\n
            window.sendInputEvent({
              type: 'keyDown',
              //@ts-ignore
              keyCode: modifiers[modifiers.length - 1],
              modifiers: modifiers.length > 1 ? [modifiers[0]] : undefined
            });
          }
          if (button.length > 1 && !specialKeyMap[button]) {
            for (var i = 0; i < button.length; i++) {
              window.sendInputEvent({
                type: 'char',
                //@ts-ignore
                keyCode: button[i]
              });
            }
          } else {
            window.sendInputEvent({
              type: 'char',
              //@ts-ignore
              keyCode: specialKeyMap[button] ? specialKeyMap[button] : button
            });
          }
        }
      });\n
      if (this.props.element.type === 'text') {
        setTimeout(() => {
          this.switchTitle(this.props.element.value);
        }, 5); /// wait for 5 milliseconds for keyboard to populate value in input
      }
    }
  };\n
  switchTitle = (value: string) => {
    // Set layout to lock to get upper case letter after a space.
    if (value.endsWith(' ') || value === '') {
      this.setState({ layout: 'lock' });
    } else {
      this.setState({ layout: 'default' });
    }
  };\n
  render() {
    let keyboardClass = this.props.isActive ? 'active' : '';
    if (this.state.layout === 'number') {
      keyboardClass += ' number';
    }
    return (
    <div id="keyboard" className={keyboardClass}>
      <Keyboard
      layout={keyboardLayout}
      layoutName={this.state.layout}
      inputName={this.props.field}
      onKeyPress={(button: string) => this.onKeyPress(button)}
      display={display}
      buttonTheme={{ buttonTheme }}
      mergeDisplay={true}
      preventMouseDownDefault={true}
      tabCharOnTab={false}
      />
    </div>
    );
  }
}\n
const mapStateToProps = ({ keyboard }: AppState) => ({
isActive: keyboard.isActive,
field: keyboard.field,
form: keyboard.form,
element: keyboard.element
});\n
const mapDispatchToProps = (dispatch: Dispatch) => ({
  showKeyboard: (show: boolean) => dispatch(showKeyboard(show))
});
\n
export default connect(
  mapStateToProps,
  mapDispatchToProps
)(AppKeyboard);`}
</CodeBlock>

<Notes>asd</Notes>

---

# TODO

1. Why not using classes & `this` is a great thing (PM example)
2. colocated lifecycle logic
3. Share logic with Hooks, comapre to clas
   s
